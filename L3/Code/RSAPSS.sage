from Crypto.Signature import pss
from Crypto.Hash import SHA256
from Crypto.PublicKey import RSA
import base64



def PSSverify(pubkey, message, signature):
    pubkey =  RSA.import_key(pubkey)
    h = SHA256.new(message)
    verifier = pss.new(pubkey)
    try:
        verifier.verify(h, signature)
        print("The signature is authentic.")
    except (ValueError, TypeError):
        print("The signature is not authentic.")


if __name__ == "__main__":

    pk2 = """-----BEGIN PUBLIC KEY-----
    MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuo1OuH9kwsaEnF6pEyBn
    BOoBXhvK9Az5CFT5jpKK/6vDf5WaoiejW4yDYn5KzwtHofx28yanWFOtcxdISkTk
    eeysAgID5nK/iGWULtaLJHx3lPyFC2cTXa/KMhZZC06pMIf2aKSDFb4pP82CgGiU
    NDRMhMrWbQKJoJQyqQ+fZ+cuj9i6iR2l08B4EEZ0lh5b8W9401LZpWt9MnmoZaGE
    k5zCtxV/9BVsN4g3JeyL+d0chdNavY+etnd3BYlFplgem5lm+zL3HZIUtYULeFAN
    XDEfH9wW/CdDpWn1dgxeYdvajV477UpQaqFFdtl5PnRlpGoF83Usvn/n3zeRMEIk
    BQIDAQAB
    -----END PUBLIC KEY-----"""
    m2 = "You are allowed to land at Geneva airport on 02.02.2022 at 13h55"
    s2 = "frpd8DKEnB5On+YyUjJzNnp/luSxTQW13yjyy1gwmhjKF33TtMY/UK5p4s1Stltgm1HfD3W8ahRPlwpSa1uvLmDBhxUZnlrGPmmJ2AiePjU/3fLWCoubYcL2QARKCg5mw7JFZsM3vnFgGKqB7GvXP7f55QoPIm+TLlg+J8Fekg1cCFoVA6d8r9dIXQfnzmfpgwCSKdm8ogQRoiYA81LNkBgkRD9U2X2482NMaBMKBhb2TIDGhR4muycOMQ9p5jVzeNqLc/TbWLyWWLpDJT65WYUqwDwgUzQZPRvF29xMwHqPoJfzvhCVQwA1Y+J0rkET3RvP+klUybuxUVZy+S3lzQ=="
    r2 = [21443139461406335336719094628849490034880873436747406087834088860312007320104788230832800734965782298045744344069554499444243458917882842999625809768540613189847712833924832946279977080895457274015764523662884601402728590710881233330392451164243002446798767116203742299764230445688787667234320358186734206808187842133780183171242306053442073370519262978321950639868059592610739129324048158756384627444335809445152195184410979557153261217217404675293510716803351566641009911813388299006841715579425489412862489733171429538065459312114154856818216312459466609568481926117897960574829518041260638291055944594574805819940, 18334306236929494982505098767770761472049652082057369258102231430208864378556049623831013916492589878018943757180840470460403208547426768863277449810249790541509701974858115210122728476024291781439094149744886693012668579141798457469739605630872778679178201115072990757879041365152347945197201408196587785084111552045884363887616830137311828644172092165808942109612359424103320857573155328293244354581092228138616306988395213425667295511172476789080085511736505757307515622312895374415920631989600135560414672286240733802569662439018287969478350197893859422447947334511021052755809188622441279457683621254922512318871, 5215699813402535231550730338478041755053989037266511941637581003157451456790900606773029263816334616503729474068442038927677663578969316294011121131949549594353095492773012253595860026264593185624135345297023638931474518286490272527247775060372675606973039054943544204117066398949228135131607949278039502480780492780222984977179096365068041149788860903950938015729242859385563448096941174384869175377207329902792305640775362627573005538213371284039957175907830800086519444545972174232972984662654061318948811813174671595352722410496364738476372292309290415160571471223284350431998070123023433932081869563874958041710, 2106866588925694877336734477399313192222767682576475111905723573054308515242161999771242445343142196476928887179728009943837413208513242157662761173658726946015084633706294517438611421393427693047464971379025730541414506717407496666594929527002451839352473053812792662231877318412788413094488999287893080756704202692327165693553620448937796423441690091437929485473542690878145176346048343921728902513963748596256417444759596496087039832168443397826531970840984990753025155045479249642051901072828707466500994366243975859856925537400497851136506177743683228040036879616407442612977740704204075098709546224222664540641]


    # Test de la fonction de vérication de la signature
    PSSverify(pk2, m2.encode('utf-8'), base64.b64decode(s2.encode('utf-8')))


    # Exploitation de la vulnérabilité

    public_key =  RSA.import_key(pk2)

    # Calcul d'un multiple de p ou q.
    multiple = r2[1] + r2[3]

    # Calcul du pgcd entre le multiple et n, ce qui va nous donner p ou q.
    gcd = gcd(multiple, public_key.n)

    # Calcul de l'autre composante de n. Si on avait p, on a q et inversement.
    other_component= public_key.n // gcd

    # Calcul de phi(n)
    phi = (other_component - 1) * (gcd - 1)

    # Calcul de d
    d = inverse_mod(public_key.e, phi)

    # Création de la clé privée
    key = RSA.construct((public_key.n, public_key.e, int(d)))

    # Message à signer pour tester la clé privée
    message_to_sign = "Atterrissage à Yverdon plage, il est 14h et le temps est magnifique.".encode('utf-8')

    # Signature du message
    sign = pss.new(key).sign(SHA256.new(message_to_sign))

    # Vérification de la signature
    PSSverify(pk2, message_to_sign, sign)



